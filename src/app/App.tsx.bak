// Import React.
import { useState, useEffect, useCallback } from "react";
import type { ReactElement } from "react";

// Import features.
import { ChatUI } from "../features/llm-chat-ui";
import type { Message } from "../features/llm-chat-ui/types";
import { LLMClientFactory } from "../shared/llm-client";
import type { LLMClient } from "../shared/llm-client";

// Import components.
import { Page } from "./components/Page";
import { SplitView } from "./components/SplitView/SplitView";
import { DirectoryExplorer } from "../features/directory-explorer";
import type { DirectoryItem } from "../features/directory-explorer";

// Import utils.
import { Profiler } from "../utils/Profiler";
import { OpenAiKeyManager } from "../utils/KeyManager";

// Import AI tools.
import { workflowAgent } from "../features/svg-canvas/tools/workflow_agent";
import { newSheet } from "./tools/new_sheet";
import { createSandbox } from "./tools/sandbox";
import { newWork } from "./tools/new_work";

// Import repository and hooks.
import { useWorks } from "./hooks/useWorks";
import { useMarkdowns } from "./hooks/useMarkdowns";
import type { WorkingItem } from "./model/WorkingItem";
import { MarkdownEditor } from "../features/markdown-editor";

declare global {
	interface Window {
		profiler: Profiler;
	}
}

if (!window.profiler) {
	window.profiler = new Profiler();
}

/**
 * 譁ｰ縺励＞繧ｷ繝ｼ繝医ｒ霑ｽ蜉縺吶ｋ縺溘ａ縺ｮ繧､繝吶Φ繝医ｒ逋ｺ陦後＠縺ｾ縺・
 * @param id - 繧ｷ繝ｼ繝医・ID
 * @param sheetName - 繧ｷ繝ｼ繝医・陦ｨ遉ｺ蜷・
 * @param sheetType - 繧ｷ繝ｼ繝医・繧ｿ繧､繝暦ｼ・anvas, sandbox縺ｪ縺ｩ・・
 */
export const dispatchAddNewSheetEvent = ({
	id,
	sheetName,
	sheetType = "canvas", // Default to canvas if not specified
}: {
	id: string;
	sheetName: string;
	sheetType?: string;
}) => {
	const event = new CustomEvent("add_new_sheet", {
		detail: {
			id,
			sheetName,
			sheetType,
		},
	});
	window.dispatchEvent(event);
};

/**
 * App繧ｳ繝ｳ繝昴・繝阪Φ繝・
 * 繧｢繝励Μ繧ｱ繝ｼ繧ｷ繝ｧ繝ｳ縺ｮ繝｡繧､繝ｳ繝ｬ繧､繧｢繧ｦ繝医ｒ螳夂ｾｩ縺励∪縺・
 */
const App = (): ReactElement => {
	// 迥ｶ諷狗ｮ｡逅・
	const [messages, setMessages] = useState<Message[]>([]);
	const [isLoading, setIsLoading] = useState(false);
	const [apiKey, setApiKey] = useState<string | null>(null);
	const [llmClient, setLLMClient] = useState<LLMClient | null>(null);
	const { works, updateWorks, addWork } = useWorks();
	const { getMarkdownById, saveMarkdown } = useMarkdowns();
	const [workingItems, setWorkingItems] = useState<WorkingItem[]>([]);
	const [selectedItem, setSelectedItem] = useState<string | undefined>(
		undefined,
	);
	// new_work繧､繝吶Φ繝医・繝上Φ繝峨Μ繝ｳ繧ｰ縺ｨEventBus縺ｮ蜿門ｾ・
	const workEventBus = newWork.useTool(async (work) => {
		try {
			await addWork(work);
			setWorkingItems((prevItems) => [
				...prevItems,
				{
					id: work.id,
					content: "",
					isEditing: false,
				},
			]);
			setSelectedItem(work.id);
		} catch (error) {
			console.error("Failed to add new work:", error);
		}
	});

	// 繝峨Λ繝・げ・・ラ繝ｭ繝・・縺ｫ繧医ｋ繧｢繧､繝・Β螟画峩縺ｮ繝上Φ繝峨Λ
	const handleDirectoryItemsChange = useCallback(
		(newItems: DirectoryItem[]) => {
			// DirectoryItem縺ｮ驟榊・繧淡ork縺ｮ驟榊・縺ｫ繝槭ャ繝斐Φ繧ｰ
			const updatedWorks = newItems.map((item) => {
				return {
					id: item.id,
					name: item.name,
					path: item.path,
					type: item.isDirectory ? "group" : item.type || "document",
				};
			});

			// 迥ｶ諷九→繧ｹ繝医Ξ繝ｼ繧ｸ繧呈峩譁ｰ
			updateWorks(updatedWorks);
		},
		[updateWorks],
	);

	// 繝輔か繝ｫ繝繧剃ｽ懈・縺吶ｋ蜃ｦ逅・
	const handleCreateFolder = useCallback(
		async (parentId: string, folderName: string) => {
			try {
				// 隕ｪ繝輔か繝ｫ繝縺ｮ諠・ｱ繧貞叙蠕・
				const parentItem = works.find((work) => work.id === parentId);
				const parentPath = parentItem ? parentItem.path : "";

				// 譁ｰ縺励＞繝輔か繝ｫ繝縺ｮ繝代せ縺ｨ荳諢上・ID繧堤函謌・
				const folderPath = parentPath
					? `${parentPath}/${folderName}`
					: folderName;
				const folderId = `folder-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

				// 譁ｰ縺励＞繝ｯ繝ｼ繧ｯ(繝輔か繝ｫ繝)繧剃ｽ懈・
				const newFolder = {
					id: folderId,
					name: folderName,
					path: folderPath,
					type: "group",
				};

				// 繝ｯ繝ｼ繧ｯ驟榊・縺ｫ霑ｽ蜉
				await addWork(newFolder);
			} catch (error) {
				console.error("Failed to create folder:", error);
			}
		},
		[works, addWork],
	);

	// 繝輔ぃ繧､繝ｫ繧剃ｽ懈・縺吶ｋ蜃ｦ逅・
	const handleCreateFile = useCallback(
		async (parentId: string, fileName: string) => {
			try {
				// 隕ｪ繝輔か繝ｫ繝縺ｮ諠・ｱ繧貞叙蠕・
				const parentItem = works.find((work) => work.id === parentId);
				const parentPath = parentItem ? parentItem.path : "";

				// 譁ｰ縺励＞繝輔ぃ繧､繝ｫ縺ｮ繝代せ縺ｨ荳諢上・ID繧堤函謌・
				const filePath = parentPath ? `${parentPath}/${fileName}` : fileName;
				const fileId = `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

				// 譁ｰ縺励＞繝ｯ繝ｼ繧ｯ(繝輔ぃ繧､繝ｫ)繧剃ｽ懈・
				const newFile = {
					id: fileId,
					name: fileName,
					path: filePath,
					type: "document",
				};

				// 繝ｯ繝ｼ繧ｯ驟榊・縺ｫ霑ｽ蜉
				await addWork(newFile); // 菴懈･ｭ繧｢繧､繝・Β縺ｨ縺励※霑ｽ蜉
				const newWorkingItem: WorkingItem = {
					id: fileId,
					content: "",
					isEditing: false,
				};
				setWorkingItems((prev) => [...prev, newWorkingItem]);

				// 菴懈・縺励◆繝輔ぃ繧､繝ｫ繧帝∈謚・
				setSelectedItem(fileId);
			} catch (error) {
				console.error("Failed to create file:", error);
			}
		},
		[works, addWork],
	);

	// 繝輔ぃ繧､繝ｫ縺ｾ縺溘・繝輔か繝ｫ繝繧貞炎髯､縺吶ｋ蜃ｦ逅・
	const handleDelete = useCallback(
		async (itemId: string) => {
			try {
				// 蜑企勁蟇ｾ雎｡縺ｮ繧｢繧､繝・Β縺ｨ縺昴・蟄仙ｭｫ繧堤音螳・
				const itemToDelete = works.find((work) => work.id === itemId);
				if (!itemToDelete) return;

				// 繧｢繧､繝・Β縺ｮ繝代せ縺ｧ蟋九∪繧九☆縺ｹ縺ｦ縺ｮ繧｢繧､繝・Β繧ょ炎髯､蟇ｾ雎｡縺ｫ・亥ｭ仙ｭｫ・・
				const itemsToDelete = works.filter(
					(work) =>
						work.id === itemId || work.path.startsWith(`${itemToDelete.path}/`),
				);
				const idsToDelete = itemsToDelete.map((item) => item.id);

				// 蜑企勁蟇ｾ雎｡螟悶・繧｢繧､繝・Β縺縺代ｒ谿九☆
				const updatedWorks = works.filter(
					(work) => !idsToDelete.includes(work.id),
				);

				// 繝ｯ繝ｼ繧ｯ驟榊・繧呈峩譁ｰ
				await updateWorks(updatedWorks);

				// 驕ｸ謚樔ｸｭ縺ｮ繧｢繧､繝・Β縺悟炎髯､蟇ｾ雎｡縺ｮ蝣ｴ蜷医・∈謚槭ｒ隗｣髯､
				if (selectedItem && idsToDelete.includes(selectedItem)) {
					setSelectedItem(undefined);
				}

				// 髢｢騾｣縺吶ｋ繝ｯ繝ｼ繧ｭ繝ｳ繧ｰ繧｢繧､繝・Β繧ょ炎髯､
				setWorkingItems((prev) =>
					prev.filter((item) => !idsToDelete.includes(item.id)),
				);
			} catch (error) {
				console.error("Failed to delete item:", error);
			}
		},
		[works, updateWorks, selectedItem],
	);

	const handleDirectoryItemSelect = useCallback(
		async (itemId: string) => {
			// itemId縺九ｉ繝ｯ繝ｼ繧ｯ繧呈､懃ｴ｢
			const item = works.find((work) => work.id === itemId);
			if (!item) return;

			// 譌｢蟄倥・菴懈･ｭ繧｢繧､繝・Β繧呈爾縺・
			const workingItem = workingItems.find((item) => item.id === itemId);
			
			if (!workingItem && item.type !== "group") {
				try {
					// 菫晏ｭ俶ｸ医∩縺ｮ繝槭・繧ｯ繝繧ｦ繝ｳ繝・・繧ｿ縺後≠繧九°遒ｺ隱・
					const savedMarkdown = await getMarkdownById(itemId);
					const content = savedMarkdown ? savedMarkdown.content : "";
					
					// 譁ｰ縺励＞繝ｯ繝ｼ繧ｭ繝ｳ繧ｰ繧｢繧､繝・Β繧剃ｽ懈・
					const newItem: WorkingItem = {
						id: itemId,
						content,
						isEditing: false,
					};
					setWorkingItems((prevItems) => [...prevItems, newItem]);
					
				} catch (error) {
					console.error(`Failed to load markdown for item ${itemId}:`, error);
					
					// 繧ｨ繝ｩ繝ｼ譎ゅ・遨ｺ縺ｮ繧ｳ繝ｳ繝・Φ繝・〒菴懈・
					const newItem: WorkingItem = {
						id: itemId,
						content: "",
						isEditing: false,
					};
					setWorkingItems((prevItems) => [...prevItems, newItem]);
				}
			}

			setSelectedItem(itemId);
		},
		[workingItems, works, getMarkdownById],
	);

	// Load OpenAI API key from KeyManager on component mount
	useEffect(() => {
		const savedApiKey = OpenAiKeyManager.loadKey();
		setApiKey(savedApiKey);
	}, []);

	// Initialize LLM client if API key provided
	useEffect(() => {
		if (apiKey) {
			// LLMClientFactory繧剃ｽｿ逕ｨ縺励※繧ｯ繝ｩ繧､繧｢繝ｳ繝医ｒ蛻晄悄蛹・
			const client = LLMClientFactory.createClient(apiKey, {
				tools: [
					workflowAgent.definition,
					newSheet.definition,
					createSandbox.definition,
					newWork.definition,
				],
				functionHandlers: {
					workflow_agent: workflowAgent.handler,
					new_sheet: newSheet.handler,
					create_sandbox: createSandbox.handler,
					new_work: newWork.createHandler(workEventBus),
				},
				systemPrompt:
					"You are a general-purpose assistant that outputs responses in Markdown format. " +
					"When including LaTeX expressions, do not use code blocks. " +
					"Instead, use inline LaTeX syntax like $...$ for inline math and $$...$$ for block math." +
					"When creating workflows, always create a new sheet first before creating the workflow itself. IMPORTANT TOOL SELECTION: When asked to create HTML content, interactive applications (like calculators, games, demos), you MUST use the create_sandbox tool, NOT workflow_agent. The create_sandbox tool is specifically designed for HTML/JavaScript applications with a complete document structure. If the user request contains keywords like '繧｢繝励Μ', '繧ｲ繝ｼ繝', '繝・Δ', 'HTML', '繧､繝ｳ繧ｿ繝ｩ繧ｯ繝・ぅ繝・, '險育ｮ玲ｩ・, '繧｢繝励Μ繧ｱ繝ｼ繧ｷ繝ｧ繝ｳ', or any interactive content that would benefit from HTML rendering, you MUST use the create_sandbox tool. Use workflow_agent ONLY for workflow diagrams, not for web applications.",
			});
			setLLMClient(client);
		} else {
			setLLMClient(null);
		}
	}, [apiKey, workEventBus]);

	// 繝√Ε繝・ヨUI縺ｮ險ｭ螳・
	const chatConfig = {
		height: "100%",
		width: "100%",
		messages: messages,
		isLoading: isLoading,
		onSendMessage: async (message: string) => {
			// 繝ｦ繝ｼ繧ｶ繝ｼ繝｡繝・そ繝ｼ繧ｸ繧定ｿｽ蜉
			const userMessage: Message = {
				role: "user",
				content: message,
				timestamp: new Date(),
			};
			setMessages((prevMessages) => [...prevMessages, userMessage]);

			// LLMClient縺悟茜逕ｨ蜿ｯ閭ｽ縺ｪ蝣ｴ蜷医・API繝ｪ繧ｯ繧ｨ繧ｹ繝医ｒ螳溯｡・
			if (llmClient) {
				try {
					setIsLoading(true);

					// 繧｢繧ｷ繧ｹ繧ｿ繝ｳ繝亥ｿ懃ｭ斐・繝励Ξ繝ｼ繧ｹ繝帙Ν繝繝ｼ繧定ｿｽ蜉
					const assistantMessage: Message = {
						role: "assistant",
						content: "",
						timestamp: new Date(),
					};
					setMessages((prevMessages) => [...prevMessages, assistantMessage]);

					// LLMClient繧剃ｽｿ逕ｨ縺励※繝ｬ繧ｹ繝昴Φ繧ｹ繧偵せ繝医Μ繝ｼ繝溘Φ繧ｰ
					await llmClient.chat({
						message: userMessage.content,
						onTextChunk: (textChunk: string) => {
							setMessages((prevMessages) => {
								const updated = [...prevMessages];
								const lastMessage = updated[updated.length - 1];
								// 譛蠕後・繝｡繝・そ繝ｼ繧ｸ・・ssistant・峨ｒ譖ｴ譁ｰ
								updated[updated.length - 1] = {
									...lastMessage,
									content: lastMessage.content + textChunk,
								};
								return updated;
							});
							setWorkingItems((prevItems) =>
								prevItems.map((item) =>
									item.id === selectedItem
										? { ...item, content: item.content + textChunk }
										: item,
								),
							);
						},
					});
				} catch (error) {
					console.error("Error calling LLM service:", error);
					// 繧ｨ繝ｩ繝ｼ繝｡繝・そ繝ｼ繧ｸ繧定ｿｽ蜉
					setMessages((prevMessages) => [
						...prevMessages,
						{
							role: "assistant",
							content:
								"逕ｳ縺苓ｨｳ縺ゅｊ縺ｾ縺帙ｓ縺後∝ｿ懃ｭ斐・逕滓・荳ｭ縺ｫ繧ｨ繝ｩ繝ｼ縺檎匱逕溘＠縺ｾ縺励◆縲ゅｂ縺・ｸ蠎ｦ縺願ｩｦ縺励￥縺縺輔＞縲・,
							timestamp: new Date(),
						},
					]);
				} finally {
					setIsLoading(false);
				}
			} else {
				// LLMClient縺悟茜逕ｨ縺ｧ縺阪↑縺・ｴ蜷医・繧ｨ繝ｩ繝ｼ繝｡繝・そ繝ｼ繧ｸ繧定｡ｨ遉ｺ
				setIsLoading(true);
				setTimeout(() => {
					const assistantMessage: Message = {
						role: "assistant",
						content:
							"API繧ｭ繝ｼ縺瑚ｨｭ螳壹＆繧後※縺・↑縺・◆繧√∝ｿ懃ｭ斐ｒ逕滓・縺ｧ縺阪∪縺帙ｓ縲・PI繧ｭ繝ｼ繧定ｨｭ螳壹＠縺ｦ縺上□縺輔＞縲・,
						timestamp: new Date(),
					};
					setMessages((prevMessages) => [...prevMessages, assistantMessage]);
					setIsLoading(false);
				}, 500);
			}
		},
	};
	const content =
		typeof workingItems.find((item) => item.id === selectedItem)?.content ===
		"string"
			? (workingItems.find((item) => item.id === selectedItem)
					?.content as string)
			: undefined;

	/**
	 * 菫晏ｭ倥・繧ｿ繝ｳ縺後け繝ｪ繝・け縺輔ｌ縺滓凾縺ｮ繝上Φ繝峨Λ
	 */
	const handleSave = useCallback(async () => {
		// 驕ｸ謚槭＆繧後※縺・ｋ繧｢繧､繝・Β縺悟ｭ伜惠縺吶ｋ蝣ｴ蜷医・縺ｿ蜃ｦ逅・ｒ螳溯｡・
		if (selectedItem) {
			try {
				console.log(`Saving content for item with ID: ${selectedItem}`);
				
				// 驕ｸ謚樔ｸｭ縺ｮ繧｢繧､繝・Β縺ｮ蜀・ｮｹ繧貞叙蠕・
				const selectedWorkingItem = workingItems.find(item => item.id === selectedItem);
				if (!selectedWorkingItem) return;
				
				// 蟇ｾ蠢懊☆繧妓ork繧貞叙蠕・
				const work = works.find(work => work.id === selectedItem);
				if (!work) return;
				
				// 繝槭・繧ｯ繝繧ｦ繝ｳ繧ｪ繝悶ず繧ｧ繧ｯ繝医ｒ菴懈・
				const markdownToSave: Markdown = {
					id: selectedItem,
					name: work.name,
					content: selectedWorkingItem.content || ""
				};
				
				// 繝槭・繧ｯ繝繧ｦ繝ｳ繧剃ｿ晏ｭ・
				await saveMarkdown(markdownToSave);
				console.log(`Content saved successfully for item with ID: ${selectedItem}`);
				
				// 邱ｨ髮・ヵ繝ｩ繧ｰ繧偵Μ繧ｻ繝・ヨ
				setWorkingItems(prev => 
					prev.map(item => 
						item.id === selectedItem ? { ...item, isEditing: false } : item
					)
				);
			} catch (error) {
				console.error("Failed to save markdown content:", error);
			}
		}
	}, [selectedItem, workingItems, works, saveMarkdown]);

	return (
		<div className="App">
			<Page onSave={selectedItem ? handleSave : undefined}>
				<SplitView
					initialRatio={[0.2, 0.6, 0.2]}
					left={
						<DirectoryExplorer
							items={works.map((work) => ({
								id: work.id,
								name: work.name,
								path: work.path,
								isDirectory: work.type === "group",
								type: work.type,
								isEditing: workingItems.some(
									(item) => item.id === work.id && item.isEditing,
								),
							}))}
							selectedNodeId={selectedItem}
							onSelect={handleDirectoryItemSelect}
							onItemsChange={handleDirectoryItemsChange}
							onCreateFolder={handleCreateFolder}
							onCreateFile={handleCreateFile}
							onDelete={handleDelete}
						/>
					}
					center={
						// 繝槭・繧ｯ繝繧ｦ繝ｳ繧ｨ繝・ぅ繧ｿ繝ｼ繧ｵ繝ｳ繝励Ν繧定｡ｨ遉ｺ・井ｸｭ螟ｮ繝壹う繝ｳ・・
						<MarkdownEditor
							markdown={content}
							onChange={(newMarkdown) => {
								setWorkingItems((prevItems) =>
									prevItems.map((item) =>
										item.id === selectedItem
											? { ...item, content: newMarkdown, isEditing: true }
											: item,
									),
								);
							}}
						/>
					}
					right={
						// 繝√Ε繝・ヨUI繧定｡ｨ遉ｺ・亥承繝壹う繝ｳ・・
						<ChatUI {...chatConfig} />
					}
				/>
			</Page>
		</div>
	);
};

export default App;
